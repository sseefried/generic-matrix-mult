Hi Sean,

I re-read your blog post. I guess I'd rushed through it distractedly last time. I like it a lot. And the slides as well.

Some comments on post & slides:

I love the look of your slides. Is it generated by LaTeX? PanDoc? Would you please send me the source?

The idea of shape types is lovely. Where did it come from? I wonder: Given an arbitrary parametrized data type, say [] or Tree, could we get the shape type by raising it to a kind and specializing to the parameter () (in either order)? I have a vague memory of some related slides from Jeremy Gibbons. Idea: perhaps instead of writing

data Tree sh a where
  Leaf   ∷ a → Tree () a
  Branch ∷ Tree m a → Tree n a → Tree (m,n) a
we’d write

data Tree (Tree ()) a where
  Leaf   ∷ a → Tree (Leaf ()) a
  Branch ∷ Tree m a → Tree n a → Tree (Branch m n) a

Similarly,

data Vec (Vec ()) a where
  Nil  ∷ a → Vec (Vec ()) a
  Cons ∷ a → Vec n a → Vec (Cons () n) a

Part of the trick here is that every data type declaration is also a data kind. See this note on data kinds and auto promotion.

There is a fairly natural Applicative instance for leaf trees, consistent with the Applicative instance for lists. Even consistent with the Applicative instance of all monads. I’d reconsider the following remarks from your blog post:

  There’s a problem with the last two cases. While I won’t go so far as to say that there is no definition we could 
  provide, it’s clear that there are a number of choices that could be taken. In each case one needs to take an 
  arbitrary element from the Branch argument and apply function f to it and the Leaf argument.

I think of “phantom types” as something different from GADTs: a parametrized type in which a “phantom” parameter occurs on the LHS of the definition but not the RHS. Sort of poor man’s GADTs.

The failure of GHC to realize completeness of these definitions irks me also. Do you know anything about the status of that issue, including whether SPJ agrees that it’s a GHC bug?

Slide 31 says “You need two instances. One for each constructor. …” I don’t use this style in type-unary. I worry that it leads to onerous class constraints for uses. For instance,

(Functor (Vec n), Applicative (Vec n), Foldable (Vec n), ⋯)  ⇒ ⋯
rather than something like

IsNat n ⇒ ⋯
In any case, I’d replace “need” here. BTW, when we have data kinds, I think things will get a lot simpler, since the kind Nat of n will imply that it’s either Z or S of a nat.

Thanks for the quote from my TCM paper. Would you please fix the first word in the title (“Denotation” → “Denotational”)?

One way I like thinking about the awkwardness of trees and lists without shapes is that their construction includes sums. The shaped GADTs look like they use sums, but the constructor result types are all disjoint.

Fun stuff! I hope you keep it up.

Warm regards, - Conal